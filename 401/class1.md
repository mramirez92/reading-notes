# 1. Class 01

## Why this is important

Moving into a more advanced way of coding will require us to understand how algorithms work. 

## Pain vs. Suffering

>"You‚Äôll be pushed mentally, having to think your way through problems that you had only even heard about a few hours beforehand."

This quote reminded me how intense these courses are. We are expected to put into work something we learned earlier that morning. That in itself is intimidating and scary. With that being taken into account, the feeling you get when your code works and runs is just of pure joy. 

## Beginners Guide to Big O

O(1) describes an algorithm that will always execute in the same time (or space) regardless of the size of the input data set.

O(N) describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set. The example below also demonstrates how Big O favours the worst-case performance scenario; a matching string could be found during any iteration of the for loop and the function would return early, but Big O notation will always assume the upper limit where the algorithm will perform the maximum number of iterations.

O(N¬≤) represents an algorithm whose performance is directly proportional to the square of the size of the input data set. This is common with algorithms that involve nested iterations over the data set. Deeper nested iterations will result in O(N¬≥), O(N‚Å¥) etc.

## Things I want to know more about

I want to know more about algorithms, very new to me. 
## Resources
[Pain vs Suffering](https://codefellows.github.io/code-401-python-guide/curriculum/class-01/notes/pain_suffering)

[A beginner's guide to Big O Notation](https://robbell.io/2009/06/a-beginners-guide-to-big-o-notation)

üìî[Back to Main Page](README.md)